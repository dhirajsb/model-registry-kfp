/*
 * Model Registry REST API
 *
 * REST API for Model Registry to create and manage ML model metadata
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"github.com/kubeflow/model-registry/pkg/openapi"
	"net/http"
)

type ModelCatalogApi interface {
	GetCatalogModel(ctx context.Context, modelId string) (openapi.CatalogModel, error)
	GetCatalogModelVersion(ctx context.Context, modelId string, versionId string) (openapi.CatalogModelVersion, error)
	GetCatalogModelVersions(ctx context.Context, modelId string, nameParam string, externalIdParam string, pageSizeParam string, orderByParam openapi.OrderByField, sortOrderParam openapi.SortOrder, offsetParam string) (openapi.CatalogModelVersionList, error)
	GetCatalogModels(ctx context.Context, nameParam string, externalIdParam string, pageSizeParam string, orderByParam openapi.OrderByField, sortOrderParam openapi.SortOrder, offsetParam string) (openapi.CatalogModelList, error)
	GetCatalogSource() (openapi.CatalogSource, error)
}

// ModelCatalogServiceAPIService is a service that implements the logic for the ModelCatalogServiceAPIServicer
// This service should implement the business logic for every endpoint for the ModelCatalogServiceAPI s.coreApi.
// Include any external packages or services that will be required by this service.
type ModelCatalogServiceAPIService struct {
	modelCatalogs map[string]ModelCatalogApi
}

func (m ModelCatalogServiceAPIService) GetCatalogModel(ctx context.Context, id string, modelId string) (ImplResponse, error) {
	catalog, ok := m.modelCatalogs[id]
	if !ok {
		return missingCatalogError(id)
	}
	response, err := catalog.GetCatalogModel(ctx, modelId)
	if err != nil {
		return ErrorResponse(http.StatusBadRequest, err), err
	}
	return Response(http.StatusOK, response), nil
}

func (m ModelCatalogServiceAPIService) GetCatalogModelVersion(ctx context.Context, id string, modelId string, modelVersionId string) (ImplResponse, error) {
	catalog, ok := m.modelCatalogs[id]
	if !ok {
		return missingCatalogError(id)
	}
	response, err := catalog.GetCatalogModelVersion(ctx, modelId, modelVersionId)
	if err != nil {
		return ErrorResponse(http.StatusBadRequest, err), err
	}
	return Response(http.StatusOK, response), nil
}

func (m ModelCatalogServiceAPIService) GetCatalogModelVersions(ctx context.Context, id string, modelId string, name string, externalId string, pageSize string, orderBy openapi.OrderByField, sortOrder openapi.SortOrder, offset string) (ImplResponse, error) {
	catalog, ok := m.modelCatalogs[id]
	if !ok {
		return missingCatalogError(id)
	}
	response, err := catalog.GetCatalogModelVersions(ctx, modelId, name, externalId, pageSize, orderBy, sortOrder, offset)
	if err != nil {
		return ErrorResponse(http.StatusBadRequest, err), err
	}
	return Response(http.StatusOK, response), nil
}

func (m ModelCatalogServiceAPIService) GetCatalogModels(ctx context.Context, id string, name string, externalId string, pageSize string, orderBy openapi.OrderByField, sortOrder openapi.SortOrder, offset string) (ImplResponse, error) {
	catalog, ok := m.modelCatalogs[id]
	if !ok {
		return missingCatalogError(id)
	}
	response, err := catalog.GetCatalogModels(ctx, name, externalId, pageSize, orderBy, sortOrder, offset)
	if err != nil {
		return ErrorResponse(http.StatusBadRequest, err), err
	}
	return Response(http.StatusOK, response), nil
}

func (m ModelCatalogServiceAPIService) GetCatalogSource(ctx context.Context, id string) (ImplResponse, error) {
	catalog, ok := m.modelCatalogs[id]
	if !ok {
		return missingCatalogError(id)
	}
	response, err := catalog.GetCatalogSource()
	if err != nil {
		return ErrorResponse(http.StatusBadRequest, err), err
	}
	return Response(http.StatusOK, response), nil
}

func (m ModelCatalogServiceAPIService) GetCatalogSources(ctx context.Context, name string, pageSize string, orderBy string, sortOrder string, offset string) (ImplResponse, error) {
	response := openapi.CatalogSourceList{
		Items: make([]openapi.CatalogSource, 0),
	}
	// TODO add support for paging
	for _, catalog := range m.modelCatalogs {
		source, err := catalog.GetCatalogSource()
		if err != nil {
			return ErrorResponse(http.StatusBadRequest, err), err
		}
		response.Items = append(response.Items, source)
	}
	return Response(http.StatusOK, response), nil
}

func missingCatalogError(id string) (ImplResponse, error) {
	err := fmt.Errorf("Missing catalog %s", id)
	return ErrorResponse(http.StatusNotFound, err), err
}

// NewModelCatalogServiceAPIService creates a default api service
func NewModelCatalogServiceAPIService(modelCatalogs map[string]ModelCatalogApi) ModelCatalogServiceAPIServicer {
	return &ModelCatalogServiceAPIService{
		modelCatalogs: modelCatalogs,
	}
}
